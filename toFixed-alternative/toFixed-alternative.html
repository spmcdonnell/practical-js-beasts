<!DOCTYPE html>
<html>
	<head>
		<title>toFixed Alternative</title>
		<link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700,800" rel="stylesheet">
		<script src="tinytest.js"></script>
		<script>
			// Helpers
			function generateZeros(thing) {
				var zerosToAdd = '';

				for (var i = 0; i < thing; i++) {
					zerosToAdd += '0';
				};

				return zerosToAdd;
			}

			function allZeros(number) {
				return number === '0';
			}

			function appendMinusSign(value, isNegative) {
				return isNegative ? '-' + value : value;
			}

			// API
			function toFixed(value, precision) {
				var value  								 = '' + value,
						absValue 							 = value.replace(/[^0-9.]/g, ''),
						isNegative        		 = value.indexOf('-') !== -1,
				    isWhole           		 = value.indexOf('.') === -1;

				// Return unaltered value if precision is undefined
				if (arguments.length < 2) {
					return appendMinusSign(absValue, isNegative);
				}

				// Whole numbers
				if (isWhole) {
					if (precision > 0) {
						return appendMinusSign(absValue + '.' + generateZeros(precision), isNegative);
					} else {
						return appendMinusSign(absValue, isNegative);
					}
				}

				// Numbers with decimals
				if(!isWhole) {
					var numsBeforeDecimal 		 = absValue.split('.')[0],
							numsAfterDecimal  		 = absValue.split('.')[1],
							numsAfterDecimalCount  = numsAfterDecimal.length,
							numsBeforeDecimalArray = numsBeforeDecimal.split(/(?=[\s\S])/u),
						  numsAfterDecimalArray  = numsAfterDecimal.split(/(?=[\s\S])/u);

					// Return unaltered value if precision is already the same as initial value's precision
					if (precision === numsAfterDecimalCount) {
						return appendMinusSign(absValue, isNegative);
					}
					// Increase precision on number with decimals
					if (precision > numsAfterDecimalCount) {
						return appendMinusSign(absValue + generateZeros(precision - numsAfterDecimalCount), isNegative);
					}
					// Decrease precision on number with decimals
					if (precision < numsAfterDecimalCount) {
						// If value must be rounded down
						if (parseInt(numsAfterDecimal[precision]) <= 4) {
							(precision === 0) ? absValue = numsBeforeDecimal : absValue = numsBeforeDecimal + '.' + numsAfterDecimal.slice(0, precision);
						} else {
							// If value must be rounded up
							numsAfterDecimalArray.splice(precision);

							var fullNumArray = numsBeforeDecimalArray.concat(numsAfterDecimalArray).reverse(),
									newValue  = [];

							//
							if (parseInt(fullNumArray[0]) < 9) {
								fullNumArray.forEach(function(item, index, array) {
									if (parseInt(item) < 9) {
										index === 0 ? newValue.push('' + (parseInt(item) + 1)) : newValue.push(item);
									} else {
										newValue.push(item);
									}
								});
							} else {
								fullNumArray.forEach(function(item, index, array) {
									if (index === 0) {
										newValue.push('0');
									} else if (newValue[index - 1] === '0') {
										if (newValue[index - 1] !== fullNumArray[index - 1]) {
											item === '9' ? newValue.push('0') : newValue.push('' + (parseInt(item) + 1));
										} else {
											newValue.push(item);
										}
									} else {
										newValue.push(item);
									}
								});
							}

							// Append a '1' to values comprised only of zeros
							if (newValue.every(allZeros)) {
								newValue.push('1');
							}

							// Add decimal back if necessary
							if (precision !== 0) {
								newValue.splice(precision, 0, '.');
							}

							return appendMinusSign(newValue.reverse().join(''), isNegative);
						}
					}
				}

				// Return result adding minus sign as necessary
				return appendMinusSign(absValue, isNegative);
			}

			// Tests

			tests({
		    	'It should return the number as a string': function() {
		    		eq(typeof toFixed(52.75, 2), 'string');
		    	},

		    	'It should retain minus signs in negative numbers': function() {
		    		eq(toFixed(-32.25), '-32.25');
		    	},

		    	'It should return the value unchaged if precision is undefined': function() {
		    		eq(toFixed(-32.25), '-32.25');
		    	},

					'It should return the value unchaged if precison is the same as inital values precision': function() {
						eq(toFixed(32.25, 2), '32.25');
					},

		    	'It should add a decimal and respective number of zeros if value is whole number and precision > 0': function() {
		    		eq(toFixed(100, 2), '100.00');
		    		eq(toFixed(-25439, 8), '-25439.00000000');
		    		eq(toFixed(25439, 0), '25439');
		    	},

		    	'It should add respective number of zeros if value has a decimal and precision > intital values precision': function() {
		    		eq(toFixed(100.0, 2), '100.00');
		    		eq(toFixed(-25439.1, 8), '-25439.10000000');
		    		eq(toFixed(25439.631, 4), '25439.6310');
		    	},

					'It should round down if necessary and apply appropriate precision': function() {
						eq(toFixed(19.454, 2), '19.45');
					},

					'It should round up if necessary and apply appropriate precision': function() {
						eq(toFixed(19.455, 2), '19.46');
						eq(toFixed(19.495, 2), '19.50');
						eq(toFixed(999.999, 2), '1000.00');
						eq(toFixed(900999.99900000, 0), '901000');
					},

					'It should return "0" without a minus sign if an initial negative value results in zero': function() {
						eq(toFixed(-0.01, 0), '0');
						eq(toFixed(-0.01, 1), '0.0');
					}
			});
		</script>
	</head>
	<body>
	</body>
</html>
